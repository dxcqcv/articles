<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="author" content="Peter Wayner ">
    <meta name="description" content="">
    <title>PHP vs. Node.js: An epic battle for developer mind share</title>
    <link rel="stylesheet" href="css/global.css" media="all">
</head>
<body>
<a href="http://www.infoworld.com/article/2866712/php/php-vs-node-js-an-epic-battle-for-developer-mind-share.html#tk.ifw-infrs">the link of articles</a><br>

<pre>
 It’s a classic Hollywood plot: the battle between two old friends who went separate ways. Often the friction begins when one pal sparks an interest in what had always been the other pal’s unspoken domain. In the programming language version of this movie, it’s the introduction of Node.js that turns the buddy flick into a grudge match: PHP and JavaScript, two partners who once ruled the Internet together but now duke it out for the mind share of developers.

In the old days, the partnership was simple. JavaScript handled little details on the browser, while PHP managed all the server-side tasks that existed between port 80 and MySQL. It was a happy union that continues to support many of the crucial parts of the Internet. Between WordPress, Drupal, and Facebook, people can hardly go a minute on the Web without running into PHP.
[ Get the low-down on the best JavaScript code tools with our review of JavaScript editors and JavaScript IDEs. | The art of programming is changing rapidly. We help you navigate what's hot in programming and what's going cold and give insights into the technologies that are changing how developers work. | Keep up with hot topics in app dev with InfoWorld's Application Development newsletter. ]

But then some clever kid discovered he could get JavaScript running on the server. Suddenly, there was no need to use PHP to build the next generation of server stacks. One language was all it took to build Node.js and the frameworks running on the client. "JavaScript everywhere" became the mantra for some.

Of course, the ending isn't written yet. For every coder crowing about the purity of Node.js and the simplicity of JavaScript everywhere, there's another who's happy with the deep code base and long-understood stability of PHP. Will the old codger beat back the server-side upstart? Will JavaScript topple its old friend to achieve world domination? Put another batch of popcorn in the microwave and sit back.
Where PHP wins: Mixing code with content

You're typing along, pouring thoughts into text for your website, and you want to add a branch to the process, a little if-then statement to make it look pretty, say, depending on some parameter in the URL. Or maybe you want to mix in text or data from a database. With PHP, you open up the magic PHP tags and start writing code within seconds. No need for templates -- everything is a template! No need for extra files or elaborate architectures, just programmable logistical power at your fingertips.
Where Node wins: Separating concerns

Mixing code with content is a crutch that can end up crippling you. Sure, it's fun to mix code in with HTML the first two or three times you do it. But soon your code base becomes a tangled mess of logic. Real programmers add structure and separate the cosmetic layer from the logical layer. It's cleaner for new programmers to understand and easier to maintain. The frameworks running on Node.js are built by programmers who know that life is better when the model, view, and controller are separate.
Where PHP wins: Deep code base

The Web is filled with PHP code. The most popular platforms for building websites (WordPress, Drupal, Joomla) are written in PHP. Not only are the platforms open source, but so are most of their plug-ins. There's PHP code everywhere, and it's waiting for you to download it, modify it, and use it for your needs.
Where Node wins: Newer code means more modern features

Sure, there are thousands of great open source PHP files, but some are 8-year-old WordPress plug-ins hoping and praying that someone will download them. Who wants to spend hours, days, or weeks monkeying with code that hasn’t been updated in years? Node.js plug-ins are not only newer; they were built with full knowledge of the latest architectural approaches. They were built by programmers who understand that modern Web apps should push most of the intelligence to the client.
Where PHP wins: Simplicity (sort of)

There's not much to PHP: a few variables and basic functions for juggling strings and numbers. It's a thin layer that doesn't do much except move the data from port 80 to the database and back. That's what it's supposed to do. A modern database is a magical tool, and it makes sense to leave the heavy lifting to it. PHP is the right amount of complexity for a job that's not supposed to be complex.
Where Node wins: Complexity of closures and more

JavaScript may have many little idiosyncrasies that drive some mad, but for the most part it is a modern language that sports a modern syntax and a few useful features like closures. You can reconfigure and extend it easily, making powerful libraries like jQuery possible. You can pass functions around like objects. Why limit yourself?
Where PHP wins: No client app needed

All of the talk about using the same language in the browser and on the server is nice, but what if you don't need to use any language on the browser? What if you ship the data in HTML form? The browser pops it up, and there are no headaches or glitches caused by misfiring JavaScript threads that try to create a page on the browser from two dozen Web service calls. Pure HTML works more often than anything else, and PHP is optimized to create that. Why bother with JavaScript on the browser? Build up everything on the server and avoid overloading that little browser on the little phone.
Where Node wins: Service calls are thinner than HTML-fat PHP calls

While AJAX-crazy HTML5 Web apps can have too many moving parts, they are cool -- and very efficient. Once the JavaScript code is in the browser cache, the only thing that moves along the wires is the new data. There's not a ton of HTML markup, and there are no repeated trips to download the entire page. Only the data has changed. If you're willing to put in the time to create a slick browser-side Web app, there's a big payoff. Node.js is optimized to deliver the data and only the data through Web services. If your app is complex and data-rich, it's a good foundation for efficient delivery.
Where PHP wins: SQL

PHP was built to co-exist with MySQL and its many variants, like MariaDB. If MySQL isn't exactly right, there are other great SQL databases from Oracle and Microsoft. Your code can switch with a few changes to your queries. The vast SQL world doesn’t end at its borders. Some of the most stable, well-developed code will interface with an SQL database, meaning all that power can also be easily integrated into a PHP project. It may not be one perfect, happy family, but it's a big one.
Where Node.js wins: JSON

If you must have access to SQL, Node.js has libraries to do that. But Node.js also speaks JSON, the lingua franca for interacting with many of the latest NoSQL databases. That’s not to say you can’t get JSON libraries for your PHP stack, but there's something fluid about the simplicity of working with JSON when using JavaScript. It's one syntax from browser to Web server to database. The colons and the curly brackets work the same way everywhere. That alone will save you from hours of frustration.
Where PHP wins: Speed of coding

For most developers, writing PHP for Web apps feels faster: no compilers, no deployment, no JAR files or preprocessors -- just your favorite editor and some PHP files in a directory. Your mileage will vary, but when it comes to banging a project together quickly, PHP is a good tool to use.
Where Node.js wins: Raw speed

Writing JavaScript code is a bit harder when you're counting curly brackets and parentheses, but when it's done, your Node.js code can fly. The callback mechanism is brilliant because it saves you from juggling the threads. The core is well-built and designed to do all that for you. Isn't that what everyone wants?
</pre>
</body>
</html>
